#!/bin/bash

set -o nounset

# =============================================
#  Global config of the application
# =============================================

PRG="$BASH_SOURCE"
while [ -h "$PRG" ] ; do
  ls=$(ls -ld "$PRG")
  link=$(expr "$ls" : '.*-> \(.*\)$')
  if expr "$link" : '/.*' > /dev/null; then
    PRG="$link"
  else
    PRG=$(dirname "$PRG")"/$link"
  fi
done

ROOT_PATH="."
if [ -x "$(command -v realpath)" ]; then
  ROOT_PATH=$(realpath "$(dirname "$PRG")")
fi

set -o allexport
source $ROOT_PATH/.env
set +o allexport

# =============================================
#  Helper that describes all functionalities
# =============================================

if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]]; then
    echo "$(basename "$0") [-h] [-e env -b backend -f file c] -- program to deal with $APP_NAME ecosystem
where:
    -h  show this help text"
    exit 0
fi

CMD="$1"
shift

# =============================================
# Global Utilities
# =============================================

function check {
  STATE=$1
  CONTAINER=${APP_NAME}-${2}
  GREP=$(docker ps | grep $CONTAINER)
  if [[ "$GREP" ]]; then
    if [[ "$STATE" == "stop" ]]; then
      exit_with_error "$CONTAINER is running. You should stop it before applying your command."
    fi
  elif [[ "$STATE" == "start" ]]; then
    exit_with_error "$CONTAINER is not running. You should start it before applying your command."
  fi
}


function exit_with_error {
  MESSAGE=${1-"end of $APP_NAME command."}
  RED='\033[0;31m'
  NO_COLOR='\033[0m'
  echo -e "${RED}""ERROR : $MESSAGE""${NO_COLOR}"
  exit 1
}


function exit_with_success {
  MESSAGE=${1-"end of $APP_NAME command."}
  GREEN='\033[0;32m'
  NO_COLOR='\033[0m'
  echo -e "${GREEN}""SUCCESS : $MESSAGE""${NO_COLOR}"
  exit 0
}


# =============================================
# Local commands : use Docker
# =============================================

# Build the docker images
if [[ "$CMD" == "build" ]]; then
  docker-compose build $*
  exit_with_success


# Apply sub command to the databases from tar db files
elif [[ "$CMD" == "database" ]]; then
  SUB_CMD=$1
  shift
  if [[ "$SUB_CMD" == "rm" ]]; then
    check stop apidb
    check stop api
    sudo rm -rf $ROOT_PATH/docker_data/apidb
  else
    check start apidb
    check start api
    docker exec $APP_NAME-apiweb bash -c "cd /opt/apiweb && PYTHONPATH=. python manager.py database $SUB_CMD"
  fi
  exit_with_success


# Connect to Postgresql database in command line using psql
elif [[ "$CMD" == "psql" ]]; then
  check start apidb
	COLUMNS=${COLUMNS:-''};
	docker exec -it $APP_NAME-apidb bash -c "COLUMNS=\"'$COLUMNS'\" psql -U '$APP_NAME'_user '${APP_NAME}_api' $*"
  exit_with_success


# Publish package to test PyPi
elif [[ "$CMD" == "prepublish" ]]; then
  VERSION=$(./$COMMAND_NAME version);
  check start api
  docker exec -it $APP_NAME-apiweb bash -c "cd /opt/apiweb &&
    rm -rf build &&
    rm -rf dist &&
    PYTHONPATH=. python setup.py sdist bdist_wheel &&
    sleep 1 &&
    twine check dist/$PIP_NAME-$VERSION.tar.gz &&
    twine upload --repository-url https://test.pypi.org/legacy/ dist/*"
  exit_with_success


# Publish package to PyPi
elif [[ "$CMD" == "publish" ]]; then
  check start api
  docker exec -it $APP_NAME-apiweb bash -c "cd /opt/apiweb && PYTHONPATH=. twine upload dist/*"
  exit_with_success

# Force docker-compose to build the docker images
elif [[ "$CMD" == "rebuild" ]]; then
  docker-compose build --no-cache $*
  exit_with_success


# Restart API after removing the database and files
elif [[ "$CMD" == "restart" ]]; then
  docker-compose down --volumes
  docker-compose up --force-recreate
  exit_with_success


# Start containers
elif [[ "$CMD" == "start" ]]; then
  docker-compose up $*
  exit_with_success


# Stop containerss
elif [[ "$CMD" == "stop" ]]; then
  docker-compose stop $*
  exit_with_success


# Create symlink to use COMMAND_NAME command (admin rights may be needed)
elif [[ "$CMD" == "symlink" ]]; then
  cd /usr/local/bin && ln -sf '"$(pwd)"'/$COMMAND_NAME $COMMAND_NAME && chmod +x $COMMAND_NAME && chmod +x '"$(pwd)"'/$COMMAND_NAME
  exit_with_success


# Run tests for API (Need start-backend to be successful and delete all data)
elif [[ "$CMD" == "test" ]]; then
  if [[ $# == 0 ]]; then
    PYTEST_ARGS="tests"
  else
    PYTEST_ARGS=$*
  fi
  check start api
  docker exec $APP_NAME-apiweb bash -c "cd /opt/apiweb && PYTHONPATH=. pytest --color=yes -rsx -v $PYTEST_ARGS"
  exit_with_success


# Get the last version of the library
elif [[ "$CMD" == "version" ]]; then
  check start api
  docker exec $APP_NAME-apiweb bash -c "cd /opt/apiweb && PYTHONPATH=. python -c \"import $MODULE_NAME; print($MODULE_NAME.__version__)\""
  exit_with_success


else
  INTERACTIVE_MODE=''
  if [[ "$CMD" == "python" ]]; then
    CMD="shell"
    INTERACTIVE_MODE='-it'
  fi
  check start api
  docker exec $INTERACTIVE_MODE $APP_NAME-apiweb bash -c "cd /opt/apiweb && PYTHONPATH=. python manager.py $CMD $*"
  exit_with_success
fi

# =============================================
# Execute command
# =============================================

exit_with_error "Did not find a matched command for '$CMD'"
